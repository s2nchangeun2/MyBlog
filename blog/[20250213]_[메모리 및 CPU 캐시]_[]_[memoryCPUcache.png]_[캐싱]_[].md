# 메모리 및 CPU 캐시

## 📌 개요

최신 CPU에는 보통 1~3개의 캐시 레벨이 있으며, 이는 **L1, L2, L3 캐시**로 구분된다.
CPU가 시스템 메모리의 주소를 읽는 명령어를 실행할 때, 하드웨어는 먼저 **L1 캐시**에 해당 데이터가 있는지 확인한다.  
만약 L1에 없다면, **L2 캐시**를 확인하고, L2에서도 찾지 못하면 **L3 캐시**를 조회한 후, 마지막으로 **시스템 메모리(RAM)**에서 데이터를 가져온다.

---

## 🛠️ 1. 캐시의 동작 방식

하드웨어는 데이터를 읽을 때 **하위 레벨 캐시에 데이터를 복사**한다.  
예를 들어:

- L3에서 데이터를 읽으면 L1과 L2에도 데이터를 복사한다.
- 시스템 메모리에서 데이터를 읽으면 모든 레벨의 캐시에 데이터를 저장한다.

이 방식은 동일한 데이터를 반복해서 접근할 가능성이 높기 때문에 유효한 **캐싱 전략**이 된다.  

하지만 **캐시의 크기는 제한적**이다.  
따라서 새로운 데이터를 저장할 때 기존 데이터를 덮어쓰게 된다.

---

## 🛠️ 2. 캐시 적중(hit)과 캐시 부적중(miss)

- **캐시 적중(hit)**: CPU가 요청한 데이터가 캐시에 저장되어 있는 경우.
- **캐시 부적중(miss)**: 캐시에 데이터가 없어 시스템 메모리에서 가져와야 하는 경우.

### 🔹 캐시와 메모리 속도 비교

| 캐시 레벨  | 상대 속도 |
|------------|-----------|
| **L1 캐시** | 가장 빠름 (L2보다 몇 배 빠름) |
| **L2 캐시** | L3보다 최소 10배 빠름 |
| **L3 캐시** | 시스템 메모리보다 최소 2배 빠름 |
| **시스템 메모리** | 가장 느림 |

CPU가 **L1 캐시에서 데이터를 읽는 것이 시스템 메모리에서 읽는 것보다 100배 이상 빠르다**.  
따라서 **캐시 부적중을 최소화하는 것이 프로그램 성능 최적화의 핵심**이다.

---

## 🛠️ 4. 캐시 최적화를 위한 프리페치(Prefetch)

**프리페치(Prefetch)**는 CPU가 데이터를 미리 로드하여 **캐시 부적중을 줄이는 기법**이다.

- 메모리를 **순차적으로 접근**하면 하드웨어가 패턴을 인식하여 데이터를 미리 캐시에 복사하다.
- 배열처럼 **연속된 데이터 구조**를 사용하면 프리페치 효과가 극대화된다.

### 🔹 프리페치의 비유

> \"CPU는 기차와 같고, 메모리는 선로이다. 기차가 지나가기 전에 선로를 미리 깔아두면 매끄럽게 달릴 수 있다.\"

프리페치는 캐시 부적중을 최소화하여 CPU가 데이터를 **최적의 타이밍**에 가져올 수 있도록 도와준다.

---

## 🎮 5. 게임 개발에서의 캐시 최적화

게임 개발에서는 캐시 최적화가 중요한 요소이다.  
예를 들어:

- **MonoBehaviour 기반 객체** (Unity C#)는 개별적으로 메모리에 저장되므로 **캐시 적중률이 낮다**.
- **DOTS(Entity Component System)**는 **연속적인 메모리 배치**를 통해 캐시 부적중을 줄이고 성능을 극대화한다.

---

## 🔚 결론 
✔️ 캐시 최적화는 **프로그램 성능을 결정짓는 중요한 요소**이다.  
✔️ 이를 잘 이해하고 활용하면 **더 빠르고 효율적인 코드**를 작성할 수 있다.



📚 **유니티 공식 문서를 참고하여 작성하였습니다.🚀**  
