# 메모리 할당 및 가비지 컬렉션

## 개요
Unity의 DOTS(Data-Oriented Technology Stack)는 데이터 지향 접근 방식을 채택하여, 기존의 MonoBehaviour 기반 객체 지향 프로그래밍보다 하드웨어 친화적인 성능을 제공한다.  
DOTS의 핵심 개념을 이해하려면 다음의 2가지 원리에 대해 이해하고 있어야 한다.

**메모리 할당 및 해제의 원리**, 그리고 **DOTS에서 메모리 관리가 어떻게 이루어지는지** 알아보자.

---

## 1. 메모리 할당이란?
운영 체제(OS)는 각 프로세스가 실행될 때 필요한 메모리를 할당한다.  
프로세스는 더 많은 메모리가 필요할 때 운영 체제에게 요청하고, OS는 연속된 메모리 블록을 제공한다. 이를 **메모리 할당(Memory Allocation)** 이라고 한다.  

프로세스가 종료되면 운영 체제는 해당 메모리를 회수하여 다른 프로그램이 사용할 수 있도록 한다. 하지만 실행 시간이 긴 프로그램의 경우, 사용하지 않는 메모리를 반환해야 하는데, 이를 **메모리 해제(Deallocation)** 또는 **할당 해제(Freeing Memory)** 라고 한다.

### 1.1 메모리 누수란?
메모리를 새롭게 할당하기만 하고 해제하지 않으면, 결국 프로그램은 지나치게 많은 메모리를 사용하게 된다. 이러한 현상을 **메모리 누수(Memory Leak)** 라고 하며, 이는 성능 저하 및 프로그램의 불안정성을 초래한다.  

---

## 2. 내부 메모리 할당자
많은 프로그램은 자체적인 **내부 할당자(Internal Allocator)** 를 사용하여 메모리를 관리한다.

1. 프로그램이 운영 체제로부터 **대규모 메모리 블록** 을 할당받음.
2. 프로그램의 내부 할당자가 현재 사용 중인 범위를 추적함.
3. 더 많은 메모리가 필요하면 운영 체제가 아니라 **내부 할당자에게 요청** 함.
4. 내부 할당된 메모리가 필요 없어지면, 프로그램이 할당자에게 이를 **해제하도록 요청** 함.  

### 2.1 내부 할당자의 장점  
✅ **성능 최적화**: 운영 체제에 직접 요청하는 것보다 빠르게 메모리를 관리할 수 있다.  
✅ **맞춤형 할당자 사용 가능**: 특정 용도에 맞는 다양한 할당자를 선택할 수 있다.  

예를 들어:
- **아레나 할당자(Arena Allocator)**: 한 번에 모든 할당을 해제할 수 있어 빠르고 효율적이다.  
- **프레임 단위 할당자**: 짧은 수명의 객체를 위한 메모리 관리 방식이다.  

---

## 3. 가비지 컬렉션(Garbage Collection)  
**가비지 컬렉터(GC, Garbage Collector)** 를 통해 사용되지 않는 메모리를 자동으로 정리한다.  

### 3.1 가비지 컬렉션의 장점  
✅ **메모리 관리 자동화**: 개발자가 직접 메모리를 해제할 필요가 없어 편리하다.  
✅ **메모리 누수 방지**: 사용하지 않는 객체를 자동으로 정리하여 불필요한 메모리 사용을 줄인다.  

### 3.2 가비지 컬렉션의 단점
❌ **성능 오버헤드**: GC가 실행될 때 CPU 자원을 소모하여 성능 저하를 유발할 수 있다.  
❌ **일시적인 실행 중단(Stop-the-World)**: GC가 실행되는 동안 프로그램이 잠시 멈추는 현상이 발생할 수 있다.  

---

## 4. DOTS에서의 메모리 관리  
DOTS는 **엔티티(Entity)와 네이티브 컬렉션(Native Collection)** 을 사용하여 기존 C#의 가비지 컬렉션 방식과는 다른 메모리 관리 방법을 제공한다.  

### 4.1 엔티티(Entity)의 메모리 관리
- **EntityManager** 를 통해 메모리 할당 및 해제를 한다.  
- 엔티티가 필요 없을 때 제거하지 않으면 메모리 누수가 발생할 수 있지만, 이는 비교적 쉽게 감지할 수 있다.  

### 4.2 네이티브 컬렉션(Native Collection)의 메모리 할당자
DOTS에서는 다양한 **Allocator(할당자)** 를 제공하여 유연한 메모리 관리를 지원한다.

| 할당자 유형 | 특징 |
|------------|------|
| **Allocator.Temp** | 한 프레임 내에서 자동 해제됨. 매우 빠름. |
| **Allocator.TempJob** | 여러 프레임 동안 유지되며, 잡(Job)이 끝나면 해제됨. |
| **Allocator.Persistent** | 명시적으로 해제하기 전까지 유지됨. 성능 비용이 크지만, 큰 데이터 저장에 유용함. |
| **WorldUpdateAllocator** | 월드 업데이트 주기에 따라 할당이 관리됨. |

---

## 5. 결론  
- 메모리 할당과 해제는 프로그램 성능과 안정성에 중요한 요소이다.  
- 가비지 컬렉션은 메모리 관리를 자동화하지만 성능 저하를 초래할 수 있다.  
- DOTS는 **EntityManager 및 네이티브 컬렉션을 활용하여 보다 효율적인 메모리 관리** 를 제공한다.







> **유니티 공식 문서를 참고하여 작성하였습니다.**  
> **썸네일은 뤼튼을 사용하였습니다.**
