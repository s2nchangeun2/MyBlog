# 멀티스레드 프로그래밍

---

## 📌 개요
**멀티코어(Multi-core) 아키텍처**를 활용하면 CPU 성능을 극대화할 수 있으며, 게임과 같은 CPU 집약적인 애플리케이션에서 큰 성능 향상을 얻을 수 있다.

하지만 멀티스레드 프로그래밍은 **데이터 동기화, 리소스 경쟁, 병렬 처리의 복잡성** 때문에 다루기 어렵다. **DOTS의 C# 잡 시스템(Job System)** 을 사용하면 이러한 문제를 안전하게 해결할 수 있다.

---

## 🛠️ 1. 멀티스레드의 기본 개념
운영 체제(OS)에서 **프로세스(Process)** 는 기본적으로 하나의 실행 스레드(Thread)로 시작된다. 하지만 프로세스는 필요에 따라 **여러 개의 스레드**를 생성하여 병렬로 실행할 수 있다.

### 🔹 1.1 CPU 코어와 스레드  
- CPU의 **각 논리적 코어(Logical Core)** 는 **한 번에 하나의 스레드**를 실행할 수 있다.
- 운영 체제는 스레드를 관리하며, 실행 중인 스레드를 중단하고 다른 스레드로 전환할 수 있다.
- 여러 개의 스레드가 **동일한 리소스(데이터)에 접근**할 경우 문제가 발생할 수 있다.

### 🔹 1.2 임계 구역(Critical Section)  
멀티스레딩 환경에서 두 개 이상의 스레드가 **동일한 메모리(공유 리소스)** 를 변경할 경우, 예기치 않은 동작이 발생할 수 있다. 이를 방지하기 위해 **임계 구역(Critical Section)** 내에서만 공유 리소스에 접근해야 한다.

**🔍 해결 방법:**  
| 동기화 기법 | 설명 |
|------------|--------------------------------------------------|
| **뮤텍스(Mutex)** | 한 번에 하나의 스레드만 공유 리소스에 접근하도록 제한 |
| **세마포어(Semaphore)** | 특정 개수의 스레드만 접근할 수 있도록 제한 |
| **락(Lock) 메커니즘** | 특정 코드 블록을 한 번에 하나의 스레드만 실행 가능하도록 제한 |
| **스핀락(Spinlock)** | 짧은 시간 동안 바쁜 대기(스핀)하며 락을 획득 |

### 🔹 1.3 동기화 기법의 작동 방식  
- **뮤텍스**: 하나의 스레드만 리소스에 접근 가능하며, 사용이 끝나면 해제해야 한다.
- **세마포어**: 정해진 개수의 스레드가 동시에 리소스에 접근할 수 있도록 제한한다.
- **락**: 특정 코드 영역을 보호하며, 락이 해제될 때까지 다른 스레드는 접근할 수 없다.
- **스핀락**: 짧은 시간 동안 CPU를 사용하여 락이 해제되기를 기다린다.
---

## ⚙️ 2. 동기화와 경쟁 상태  
멀티스레드 프로그래밍에서 가장 흔한 문제는 **경쟁 상태(Race Condition)** 와 **데드락(Deadlock)** 이다.

### ✅ 2.1 경쟁 상태(Race Condition)  
- 두 개 이상의 스레드가 **동시에 같은 메모리 영역을 수정**할 때, 예상하지 못한 결과가 발생하는 현상
- 데이터 불일치 및 예측 불가능한 버그를 유발

**🔹 해결 방법:**
- **락(Lock) 사용**: 특정 코드 블록을 한 번에 하나의 스레드만 실행할 수 있도록 제한
- **원자적 연산(Atomic Operation)**: 단일 명령어로 실행되는 연산 사용

### ⚠️ 2.2 데드락(Deadlock)  
- 두 개 이상의 스레드가 서로가 필요로 하는 리소스를 점유한 상태에서 **영원히 대기하는 현상**
- 프로그램이 멈추고 응답하지 않는 문제가 발생

**🔹 해결 방법:**
- 락을 걸기 전에 **리소스 확보 순서를 정의**하여 교착 상태 방지
- **타임아웃 설정**을 통해 일정 시간이 지나면 락을 해제

---

## 🎮 3. 멀티스레딩과 유니티 DOTS  
유니티 DOTS에서는 **C# 잡 시스템(Job System)** 을 활용하여 멀티스레딩을 안전하고 효율적으로 사용할 수 있다.

### 🔹 3.1 C# 잡 시스템 (Job System)

잡 시스템은 기본적으로 **스레드 풀(Thread Pool)**을 활용하여 여러 작업을 병렬로 처리하고, **데이터 경합(Data Contention)** 문제를 최소화하며, **버스트 컴파일러(Burst Compiler)**와 함께 사용 시 성능을 극대화할 수 있다.

#### 1. 스레드 풀(Thread Pool) 사용

**스레드 풀(Thread Pool)**을 활용하여 작업을 병렬로 처리한다. 스레드 풀은 시스템에서 미리 준비된 스레드들을 관리하여, 필요할 때마다 새로운 스레드를 생성하는 대신 기존의 스레드를 재사용한다. 이를 통해 스레드 생성에 드는 비용을 줄이고, 리소스를 효율적으로 관리할 수 있다.

- **원리**: 스레드 풀은 작업 큐에 들어온 작업들을 스레드 풀에 있는 스레드들이 순차적으로 처리한다다. 작업이 많을 경우, 스레드가 부족하지 않도록 자동으로 스레드를 관리하고, 필요에 따라 추가적인 스레드를 생성할 수 있다.
- **장점**: 스레드를 생성하는 데 드는 비용을 줄이고, 빠른 작업 처리가 가능하다. 또한, 작업이 끝난 후 스레드를 재사용하기 때문에 메모리 관리가 효율적이다.

#### 2. 데이터 경합(Data Contention) 최소화

멀티스레딩 환경에서 여러 스레드가 동일한 데이터를 동시에 수정하려고 할 때 **데이터 경합(Data Contention)** 문제가 발생할 수 있다. 이 문제를 해결하기 위해 잡 시스템은 **명시적인 락을 최소화**하고, 각 스레드가 독립적으로 작업할 수 있도록 설계되었다.

- **원리**: 잡 시스템은 데이터를 독립적으로 처리할 수 있는 작은 단위로 나누어 각 스레드에 할당한다. 이렇게 하면 각 스레드는 다른 스레드와 데이터를 공유하지 않거나, 최소한으로 공유하므로 락을 걸 필요가 줄어든다. 
- **장점**: 락을 최소화하면, 스레드가 대기하는 시간이 줄어들어 성능이 향상된다. 또한, 여러 스레드가 동시에 작업을 처리하면서도 데이터 경합 없이 효율적으로 작업을 할 수 있다.

#### 3. 버스트 컴파일러(Burst Compiler)와의 연계

**버스트 컴파일러(Burst Compiler)**는 잡 시스템과 함께 사용하여 성능을 극대화할 수 있는 도구이다. 버스트 컴파일러는 C# 코드를 고급 최적화된 네이티브 코드로 변환하여 성능을 극대화한다. 특히, 고급 **SIMD(Single Instruction, Multiple Data)** 명령어를 활용하여 멀티코어 CPU의 성능을 최대한 이끌어낸다.

- **원리**: 버스트 컴파일러는 C# 코드를 컴파일할 때 네이티브 코드로 변환하고, 이 과정에서 SIMD 명령어나 벡터화(vectorization) 등의 최적화 기술을 사용하여 병렬 처리를 더 효율적으로 만들어 준다. 이를 통해 계산을 더욱 빠르게 처리할 수 있다.
- **장점**: 버스트 컴파일러를 사용하면 CPU의 성능을 극대화하여 실시간 처리, 대규모 계산 등에 필요한 성능을 확보할 수 있다.

#### 활용 예시

C# 잡 시스템은 게임 개발, 실시간 애플리케이션, 대규모 데이터 처리 등 다양한 분야에서 사용된다. 예를 들어, Unity의 **ECS(Entity Component System)**와 결합하여, 게임에서 엔티티들의 작업을 병렬로 처리할 수 있다. 이때, C#의 잡 시스템을 활용하면 여러 작업을 효율적으로 병렬 처리하여 게임의 성능을 크게 향상시킬 수 있다.

#### 주요 이점

- **성능**: 병렬 처리 및 버스트 컴파일러 덕분에 계산 속도가 크게 향상된다.
- **안정성**: 락을 최소화하고, 데이터를 안전하게 처리하여 경합 문제를 방지한다.
- **유연성**: 다양한 시스템에 적용 가능하며, 복잡한 멀티스레딩 코드를 간결하게 작성할 수 있다.

### 🔹 3.2 잡 시스템의 주요 특징  
| 기능 | 설명 |
|------------|------------------------------------------------------|
| **IJob** | 기본적인 잡 인터페이스, 단일 실행 |
| **IJobParallelFor** | 동일한 작업을 여러 개의 스레드에서 병렬 실행 |
| **IJobParallelForTransform** | 트랜스폼(Transform)과 함께 병렬 처리 |
| **NativeArray** | 멀티스레드 환경에서 안전한 데이터 구조 |

### ✅ 3.3 DOTS를 활용한 멀티스레드 코드 예제  
```csharp
using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;

[BurstCompile]
public struct MyParallelJob : IJobParallelFor
{
    public NativeArray<float> data;
    
    public void Execute(int index)
    {
        data[index] = Mathf.Sqrt(data[index]);
    }
}

public class JobSystemExample : MonoBehaviour
{
    private void Start()
    {
        NativeArray<float> dataArray = new NativeArray<float>(100, Allocator.TempJob);
        MyParallelJob job = new MyParallelJob { data = dataArray };
        JobHandle handle = job.Schedule(dataArray.Length, 10);
        handle.Complete();
        dataArray.Dispose();
    }
}
```

**🔹 코드 설명:**
1. `IJobParallelFor` 를 사용하여 데이터 배열을 병렬 처리
2. `BurstCompile` 을 적용하여 성능 최적화
3. `JobHandle` 을 활용하여 실행 흐름을 제어

---

## 🔚 결론  
✔️ 멀티스레드 프로그래밍은 성능 최적화에 필수적이지만, 데이터 동기화와 경쟁 상태를 주의해야 한다.  
✔️ **C# 잡 시스템(Job System)** 을 사용하면 안전하고 최적화된 병렬 처리가 가능하다.  
✔️ **DOTS의 잡 시스템과 버스트 컴파일러** 를 활용하면 더욱 강력한 멀티스레드 프로그래밍을 구현할 수 있다.  





📚 **유니티 공식 문서를 참고하여 작성하였습니다.🚀**  

